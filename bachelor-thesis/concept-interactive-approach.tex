%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Approach for Interactive Diagram-Specific %
% Layout of Graph-based Software Diagrams   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Ansatz für das interaktive und diagrammspezifische Layout von graphbasierten Softwarediagrammen}
\label{chapter:interactive-approach}

In diesem Kapitel wird ein Ansatz für das interaktive und diagrammspezifische Layout von graphbasierten Diagrammen präsentiert. Zunächst werden im Abschnitt \ref{sec:criteria} die Kriterien für den Entwurf des Ansatzes aufgestellt. Eine kurze Übersicht der Funktionsweise wird im Abschnitt \ref{sec:functionality} gegeben. Im Abschnitt \ref{sec:interaction-mechanisms} werden die Mechanismen der Interaktion näher erläutert. Eine detaillierte Beschreibung der Layout-Patterns und deren Rolle in dem präsentierten Ansatz folgt im Abschnitt \ref{sec:layout-patterns}. Im Abschnitt \ref{sec:layout-calculation} wird erklärt, wie das Layout berechnet wird. Schließlich wird im Abschnitt \ref{sec:current-approaches-comparison} eine Abgrenzung zu bestehenden Ansätzen beschrieben.

%%%%%%%%%%%
% Critera %
%%%%%%%%%%%

\section{Kriterien}
\label{sec:criteria}

Im Folgenden werden Kriterien für den präsentierten Ansatz aufgestellt. Die Wahl der Kriterien stützt sich in erster Linie auf die Prinzipien für die agile Modellierung aus \cite{Ambler02Agile}. Weiterhin orientieren sich die Kriterien an den im Kapitel \ref{chapter:existing-approaches} vorgestellten Ansätzen, deren positiven Eigenschaften in die Auswahl einfließen.   Schließlich haben auch die ästhetischen Prinzipien (siehe Abschnitt \ref{sec:aesthetics-criteria}) sowie die Rahmenbedingungen dieser Arbeit (siehe Abschnitt \ref{sec:thesis-conditions}) einen Einfluss auf die gewählten Kriterien.

\begin{enumerate}[label={K.\arabic*}]
    \item \label{req:gui} \textbf{GUI} Wie bereits im Abschnitt \ref{sec:thesis-conditions} erwähnt wurde, beschäftigt sich diese Arbeit ausschließlich mit Mechanismen für das Layout von Diagrammen, die in Tools für klassische grafische Benutzeroberflächen eingesetzt werden. Daher soll der Ansatz für klassische grafische Benutzeroberflächen ausgelegt sein und von üblichen GUI-basierten Bedientechniken wie z.B. \enquote{Drag and Drop} Gebrauch machen.
    \item \label{req:interactivity} \textbf{Interaktivität} Die Manipulation mit dem Diagramm soll interaktiv erfolgen. Der Nutzer soll in der Lage sein, mit dem Diagramm unmittelbar interagieren zu können und die Layout-Anpassungen sollen eine direkte Auswirkung auf das manipulierte Diagramm haben. Demzufolge soll die Eingabe mit der Ausgabe fest gekoppelt sein\footnote{Die Kopplung bezieht sich auf den Mauszeiger und den darunterliegenden Canvas. Aus der Sicht der Mensch-Computer-Interaktion ist die Nutzung der Maus als Eingabegerät von der Ausgabe am Monitor stets entkoppelt.}.
    \item \label{req:immediate-feedback} \textbf{Unmittelbares Feedback} Bei einer direkten Manipulation mit dem Diagramm soll dem Nutzer ein unmittelbares Feedback gegeben werden, so dass das Ergebnis der Manipulation während ihrer Ausführung sichtbar wird \cite[S.69]{Wybrow08Using}.
    \item \label{req:editing-support} \textbf{Förderung des Prozesses der Diagramm-Erstellung} Der Nutzer soll den Inhalt des Diagramms bearbeiten und inkrementell modifizieren können \cite{GladischSchumann14Semi-Automatic}. Dabei soll das Layout nach jeder Änderung des Inhalts angepasst werden. Weiterhin soll es möglich sein, das Layout des Diagramms bis zu einem bestimmten Grad nach den Präferenzen des Nutzers beeinflussen zu können.
    \item \label{req:mental-map} \textbf{Erhaltung des mentalen Modells} Die Layout-Änderungen im Diagramm sollen möglichst intuitiv erfolgen, insbesondere soll das mentale Modell erhalten werden (siehe Abschnitt \ref{subsec:mental-map}).
    \item \label{req:focus-on-the-content} \textbf{Förderung der Konzentration auf den Inhalt} Der Inhalt eines Diagramms soll eine wichtigere Rolle als seine Repräsentation haben \cite[S.38ff]{Ambler02Agile}. Diese Tatsache soll in dem Ansatz berücksichtigt werden, indem der Aufwand für das Erzeugen des Layouts verringert wird. Außerdem sollen die Aktionen zur Anpassung der visuellen Eigenschaften möglichst eingeschränkt sein, ohne einen negativen Einfluss auf die Ästhetik des Layouts zu haben (siehe Kriterium \ref{req:aesthetics-criteria}).
    \item \label{req:aesthetics-criteria} \textbf{Berücksichtigung der ästhetischen Prinzipien} Die Layout-Berechnung soll unter Berücksichtigung der im Abschnitt \ref{sec:aesthetics-criteria} beschriebenen ästhetischen Prinzipien für graphbasierte Softwarediagramme erfolgen.
    \item \label{req:syntax-and-semantics} \textbf{Berücksichtigung der Syntax und Semantik} Die Syntax- und Semantikregeln der einzelnen Diagrammtypen sollen berücksichtigt werden und die Möglichkeit der Verletzung der Regeln sollte verhindert werden.
    \item \label{req:user-friendly} \textbf{Benutzerfreundlichkeit} Der Ansatz soll möglichst benutzerfreundlich sein. Insbesondere ist wichtig, die Manipulation mit dem Diagramm intuitiv zu gestalten und insbesondere eine potenzielle Frustration der Nutzer durch die Einschränkungen der Layout-Möglichkeiten zu verhindern.
\end{enumerate}

%%%%%%%%%%%%%%%%%
% Functionality %
%%%%%%%%%%%%%%%%%

\section{Funktionsweise}
\label{sec:functionality}

Der präsentierte Ansatz operiert auf dem Modell der konkreten Syntax einer graphbasierten visuellen Sprache und berechnet die Layout-Eigenschaften für Knoten und Kanten eines Diagramms (siehe Abschnitt \ref{subsec:graph-based-diagrams}). Die Berechnung erfolgt \textbf{halbautomatisch}, denn der Nutzer kann den Layout-Prozess durch die Interaktion mit dem Diagramm beeinflussen. Dabei wird versucht, ein optimales Verhältnis zwischen der Möglichkeit der flexiblen Modifizierung der Layout-Eigenschaften durch den Nutzer und einer automatisierten Layout-Berechnung zu erreichen. Der Ansatz kombiniert die Vorteile des manuellen und automatischen Layouts und lässt sich daher in die Gruppe der Ansätze für das interaktive halbautomatische Layout einordnen (siehe Abschnitt \ref{sec:interactive-semi-automatic-layout}).

Die Interaktion des Nutzers mit dem Diagramm erfolgt durch die Ausführung von \textbf{Bearbeitungsaktionen}, die mit Hilfe von \textbf{Bedienungsmechanismen} im Diagram realisiert und veranschaulicht werden. Für jede Bearbeitungsaktion werden ein oder mehrere \textbf{Layout-Ereignisse} erzeugt, die die Änderung in dem Diagramm beschreiben. Die erzeugten Layout-Ereignisse werden durch eine \textbf{Layout-Engine} ausgewertet, die für den Typ des Diagramms speziell angepasst ist. Intern verwaltet sie Instanzen von \textbf{Layout-Patterns}, die die Struktur des Diagramms beschreiben. Anhand des aktuellen Inhalts und Layouts des Diagramms und der instanziierten Layout-Patterns wird eine Anpassung des Layouts berechnet, die auf das Diagramm angewendet wird, wobei der Layout-Übergang visualisiert wird.

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Interaction Mechanisms %
%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Mechanismen der Interaktion}
\label{sec:interaction-mechanisms}

Das Kriterium \ref{req:editing-support} erfordert eine Möglichkeit der Bearbeitung des Diagramms. Der Nutzer soll in der Lage sein, neue Knoten und Kanten hinzuzufügen und bestehende Knoten und Kanten zu manipulieren bzw. zu löschen. Durch das Kriterium \ref{req:interactivity} wird gefordert, dass die Bearbeitung interaktiv erfolgt. Dies wird durch die Unterstützung von \textbf{Bearbeitungsaktionen} gewährleistet, die die Grundlage der Interaktion bilden. Die Bearbeitungsaktionen werden im Abschnitt \ref{subsec:edit-actions} im Detail beschrieben.

Weiterhin sollen die Möglichkeiten der Interaktion eingeschränkt werden, um das Ablenken durch die eventuellen Layout-Anpassungen zu minimieren (Kriterium \ref{req:focus-on-the-content}). Dies wird durch die Einschränkung der aus den manuellen Layout-Ansätzen (siehe Abschnitt \ref{sec:manual-layout}) bekannten freien Positionierung der Knoten und den Einsatz eines \textbf{neuen Bedienungsmechanismus} für die Verschiebungsoperation erreicht, dem sich der Abschnitt \ref{subsec:temporary-layer-mechanism} widmet.

Die Erhaltung des mentalen Modells (Kriterium \ref{req:mental-map}) wird durch eine \textbf{Animation der Layout-Übergänge} gefördert, womit sich der Abschnitt \ref{subsec:layout-transition} beschäftigt.

\subsection{Bearbeitungsaktionen}
\label{subsec:edit-actions}

Die interaktiven Ansätze werden in Editoren eingesetzt, die in der Regel über einen Canvas verfügen. Der Canvas ist ein rechteckiger Bereich des Editor-Fensters, in dem das Diagramm dargestellt wird und in dem die Interaktion mit dem Diagramm stattfindet. Die Interaktion setzt sich aus Bearbeitungsaktionen zusammen, die durch den Nutzer ausgeführt werden. Um das Kriterium \ref{req:gui} zu erfüllen, sollen alle Bearbeitungsaktionen auf GUI-Techniken basieren.

In dieser Arbeit werden die grundlegenden Bearbeitungsaktionen präsentiert, die insbesondere für die Entwicklung des Prototyps (siehe Kapitel \ref{chapter:prototype}) eine wichtige Rolle spielen. Natürlich ist eine Erweiterung der unterstützten Bearbeitungsaktionen möglich.

Je nach der Art der Modifizierung lassen sich die Bearbeitungsaktionen in zwei Gruppen unterteilen. Zum einen sind das Aktionen, die den Inhalt des Diagramms modifizieren und zu anderem sind das Aktionen, die das Layout des Diagramms modifizieren, ohne den Inhalt zu verändern.

\subsubsection{Bearbeitungsaktionen zur Modifizierung des Inhalts}

Zu den Bearbeitungsaktionen, die den Inhalt verändern, gehört das Hinzufügen und Löschen von Knoten bzw. Kanten und die Veränderung ihrer Eigenschaften wie z.B. das Umbenennen der Knoten. Da die Intention für die Ausführung dieser Aktionen nicht die Anpassung des Layouts ist, weisen diese Aktionen ein verzögertes Feedback auf, d.h. das Layout wird erst nach der Beendigung der Bearbeitung angepasst\footnote{Eine Ausnahme bildet das Hinzufügen eines neuen Knoten, das sich ähnlich wie die Verschiebungsaktion aus dem Abschnitt \ref{subsubsec:edit-action-for-modifying-layout} verhält.}.

\subsubsection{Bearbeitungsaktionen zur Modifizierung des Layouts}
\label{subsubsec:edit-action-for-modifying-layout}

Ein einziger Vertreter der Bearbeitungsaktionen, die ausschließlich das Layout modifizieren, ist die Verschiebung eines Knotens. Aufgrund der Einschränkung der freien Positionierung wird durch die Verschiebung eine Empfehlung für die Position eines Knotens angegeben. Diese Aktion macht sich einen neuen Bedienungsmechanismus zunutze, der ein unmittelbares Feedback aufweist und näher im Abschnitt \ref{subsec:temporary-layer-mechanism} beschrieben wird. Dieser Mechanismus bildet die Grundlage des gesamten Ansatzes.

\subsection{Mechanismus der temporären Schicht}
\label{subsec:temporary-layer-mechanism}

Alle interaktiven Ansätze für das Layout von Diagrammen aus dem Kapitel \ref{chapter:existing-approaches} bis auf das \enquote{Smart Layout} in \textit{MindNode} (siehe Abschnitt \ref{subsubsec:smart-layout-in-mindnode}) unterstützen \textbf{freie Positionierung} der Objekte im Diagramm. Diese Art der Bedienung wird im manuellen Layout zusätzlich um temporäre Hilfefunktionen (siehe Abschnitt \ref{sec:manual-layout}) und in Struktur-basierten benutzergesteuerten Ansätzen um Möglichkeit der Erzeugung von Strukturregeln (siehe Abschnitt \ref{subsec:structure-based-user-controlled-approaches}) erweitert. Durch diese Erweiterungen wird die freie Positionierung eingeschränkt, wodurch in der Regel ein besseres Layout des Diagramms erreicht werden kann. Dahingegen ist die freie Positionierung in \enquote{Smart Layout} in \textit{MindNode} und dem in dieser Arbeit präsentierten Ansatz \textbf{nicht gestattet}. Stattdessen wird durch die Verschiebung der Objekte ihre ungefähre Position angegeben, die intern ausgewertet wird und eine Anpassung des Layouts bewirkt.

Dieses Verhalten wird für die Verschiebungsaktion der Knoten eingesetzt, indem bei der Verschiebung eines Knotens eine temporäre Schicht erzeugt wird, in der sich der Knoten frei positionieren lässt. Im Diagramm wird der manipulierte Knoten durch einen Platzhalter repräsentiert, der nur erlaubte Positionen annehmen kann. Dieser Mechanismus basiert auf der Technik \textbf{\enquote{Drag and Drop}} und ist in drei Phasen aufgeteilt. Im Folgendem wird er an einem Beispiel detailliert erklärt.

Bevor die Verschiebungsaktion beginnen kann, müssen sich im Canvas einige Knoten befinden, so wie es der Fall in Abbildung \ref{fig:movement-action-example-a} ist.

In der ersten Phase wird ein Knoten im Canvas angeklickt, das in Abbildung \ref{fig:movement-action-example-b} durch einen Mauszeiger gekennzeichnet ist. Dabei wird der angeklickte Knoten in eine neu eingefügte \textbf{temporäre Schicht} ausgelagert, die vor dem Canvas positioniert ist, so wie es in Abbildung \ref{fig:temporary-layer-visualization} skizziert ist. Im Canvas wird die ursprüngliche Darstellung des verschobenen Knotens durch einen \textbf{temporären Platzhalter} ersetzt, das dem Nutzer die Zielposition des Knotens andeutet. Der Platzhalter ist in Abbildungen \ref{fig:movement-action-example-c} und \ref{fig:temporary-layer-visualization} durch ein Rechteck repräsentiert, das mit einer grauen gestrichelten Linie umrandet ist.

\begin{figure}[hbt]
    \newcommand{\subfigurewidth}{0.28\textwidth}
    \newcommand{\graphicsscale}{1.2}
    \centering
    \begin{subfigure}{\subfigurewidth}
        \centering
        \includegraphics[scale=\graphicsscale]{resources/movement-action-example-a}
        \caption{}
        \label{fig:movement-action-example-a}
    \end{subfigure}
    \begin{subfigure}{\subfigurewidth}
        \centering
        \includegraphics[scale=\graphicsscale]{resources/movement-action-example-b}
        \caption{}
        \label{fig:movement-action-example-b}
    \end{subfigure}
    \begin{subfigure}{\subfigurewidth}
        \centering
        \includegraphics[scale=\graphicsscale]{resources/movement-action-example-c}
        \caption{}
        \label{fig:movement-action-example-c}
    \end{subfigure}
    \begin{subfigure}{\subfigurewidth}
        \centering
        \includegraphics[scale=\graphicsscale]{resources/movement-action-example-d}
        \caption{}
        \label{fig:movement-action-example-d}
    \end{subfigure}
    \begin{subfigure}{\subfigurewidth}
        \centering
        \includegraphics[scale=\graphicsscale]{resources/movement-action-example-e}
        \caption{}
        \label{fig:movement-action-example-e}
    \end{subfigure}
    \caption{Beispiel einer Verschiebungsaktion}
    \label{fig:movement-action-example}
\end{figure}

\begin{figure}[hbt]
    \newcommand{\subfigurewidth}{0.35\textwidth}
    \newcommand{\graphicsscale}{0.95}
    \centering
    \begin{subfigure}{\subfigurewidth}
        \centering
        \includegraphics[scale=\graphicsscale]{resources/temporary-layer-visualization-a}
        \caption{}
    \end{subfigure}
    \begin{subfigure}{\subfigurewidth}
        \centering
        \includegraphics[scale=\graphicsscale]{resources/temporary-layer-visualization-b}
        \caption{}
    \end{subfigure}
    \caption{Darstellung der temporären Schicht vor dem Canvas}
    \label{fig:temporary-layer-visualization}
\end{figure}

In der zweiten Phase findet eine Bewegung des Mauszeigers statt. Da die temporäre Schicht an den Mauszeiger gebunden ist, wird die ausgelagerte Darstellung des Knotens frei mit dem Mauszeiger bewegt, währenddessen der Platzhalter im Canvas seine Position zunächst nicht ändert. Dies ist in Abbildung \ref{fig:movement-action-example-c} illustriert.

Die Position des Mauszeigers wird nach jeder Bewegung ausgewertet und sobald sich der Mauszeiger in einem bestimmten Bereich des Diagramms befindet, für den das Layout geändert werden soll, wird das Layout im unterliegenden Canvas mit Hilfe einer Animation (siehe Abschnitt \ref{subsec:layout-transition}) angepasst. Dabei wird die Änderung der Layout-Eigenschaften des verschobenen Knotens auf den Platzhalter angewendet, so wie es in Abbildung \ref{fig:movement-action-example-d} dargestellt ist. Durch die Anpassung des Layouts während der Interaktion wird ein unmittelbares Feedback erreicht (Kriterium \ref{req:immediate-feedback}). Dagegen wird das Layout in \textit{MindNode} (siehe Abschnitt \ref{subsubsec:smart-layout-in-mindnode}) erst nach dem Loslassen der Maustaste angepasst und damit das Feedback verzögert.

Dieser Abschnitt beschäftigt sich ausschließlich mit der Beschreibung der Interaktion, die konkrete Funktionsweise der Layout-Berechnung kann in Abschnitt \ref{sec:layout-calculation} nachgelesen werden.

Die dritte Phase beginnt mit dem Loslassen der Maustaste. Danach springt der verschobene Knoten auf seine Zielposition hin, nämlich die Position des Platzhalters. Anschließend werden der Platzhalter sowie die temporäre Schicht entfernt und die Verschiebungsaktion wird beendet. Die Abbildung \ref{fig:movement-action-example-e} zeigt den Endzustand.

\subsection{Layout-Übergänge}
\label{subsec:layout-transition}

In vorhergehenden Abschnitten wurde beschrieben, dass nach der Änderung des Inhalts bzw. währen der Verschiebung eines Knotens das Layout angepasst wird. Konkret handelt es sich um einen Übergang vom aktuellen zu einem neu berechneten Layout. Um diese Übergänge für den Nutzer nachvollziehbar zu machen, wird eine Animation eingesetzt, die insbesondere für die Erhaltung des mentalen Modells sorgt (Kriterium \ref{req:mental-map}).

%%%%%%%%%%%%%%%%%%%
% Layout Patterns %
%%%%%%%%%%%%%%%%%%%

\section{Layout-Patterns}
\label{sec:layout-patterns}

% TODO: Layout-Patterns erklären, Hinweis auf den Pattern-basierten Ansatz
Die Layout-Patterns dienen der Beschreibung der Struktur des Layouts eines Diagramms. Die Auffassung der Layout-Patterns in dieser Arbeit ist im Vergleich zu dem Konzept aus \cite{Maier12A-Pattern-based} sehr vereinfacht. Das liegt daran, dass sich diese Arbeit hauptsächlich mit der Problematik der Interaktion beschäftigt. Zwecks Vereinfachung werden die Layout-Patterns nicht an einem separaten Metamodell definiert, sondern direkt auf dem Metamodell der konkreten Syntax des gewählten Beispiels. Dennoch stellt die Arbeit neue Konzepte für die Erweiterung der Layout-Patterns vor, wie z.B. die Aufteilung auf implizite und explizite Patterns und das Konzept der Variierung der Layout-Patterns.

\subsection{Implizite Layout-Patterns}
\label{subsec:implicit-layout-patterns}

Die impliziten Layout-Patterns beschreiben allgemeine Eigenschaften für die Layout-Berechnung. Dafür werden keine expliziten Strukturregeln erzeugt, wie das der Fall bei den expliziten Layout-Patterns (siehe Abschnitt \ref{subsec:explicit-layout-patterns}) ist, sondern sie werden von dem Algorithmus der Layout-Berechnung einfach angenommen.

\subsubsection{Größe der Knoten}

In allen interaktiven Ansätzen für das Layout von Diagrammen aus dem Kapitel \ref{chapter:existing-approaches} hat der Nutzer die Möglichkeit die Größe der Objekte zu verändern. Weiterhin werden in dem allgemeinen Ansatz aus \cite{Maier12A-Pattern-based} Layout-Patterns präsentiert, die Regeln für die Größe der Objekte beschreiben. Somit ist die Größe der Objekte eine Eigenschaft, die zum einen von dem Nutzer und zu anderem von dem Layout-Algorithmus geändert werden kann.

Dagegen ist die Größe der Knoten in dieser Arbeit ausschließlich durch den Inhalt des Knotens bestimmt. Sie nimmt zunächst eine minimale Größe an und wenn der Inhalt\footnote{Für eine Klasse der Notationssprache UML handelt es sich um ihre Bezeichnung und die Liste der Attribute und Methoden.} in den Knoten mit der minimalen Größe nicht passt, wird der Knoten entsprechend erweitert. Somit kann die Größe der Knoten weder durch den Nutzer noch durch die Layout-Berechnung geändert werden. Dieses implizite Layout-Pattern fördert insbesondere die Konzentration auf den Inhalt (Kriterium \ref{req:focus-on-the-content}) und die ästhetische Gestaltung (Kriterium \ref{req:aesthetics-criteria}).

\subsubsection{Verhinderung der Knoten-Überlappung}

% TODO: Nach den ästhetischen Kriterien im Kapitel 2 ergänzen!

\subsubsection{Zentrierung des Diagramm-Inhalts}
\label{subsubsec:centering-of-diagram-content}

Die Zentrierung des Diagramm-Inhalts ist ein weiteres ästhetisches Layout-Pattern, das eine eindeutige Bestimmung des Layouts ermöglicht. Die Berechnung des Layouts erfolgt relativ und wird dermaßen auf das Diagramm angewendet, so dass der Diagramm-Inhalt immer in die Mitte des Canvas platziert wird. Dies wird in Abbildung \ref{fig:layout-pattern-centered-content} veranschaulicht.

\begin{figure}[hbt]
    \centering
    \includegraphics{resources/layout-pattern-centered-content}
    \caption{Die Zentrierung des Diagramm-Inhalts im Canvas}
    \label{fig:layout-pattern-centered-content}
\end{figure}

Dieses Layout-Pattern fördert die Ästhetik (Kriterium \ref{req:aesthetics-criteria}) und vor allem macht die Einschränkung der freien Positionierung (siehe Abschnitt \ref{subsec:temporary-layer-mechanism}) möglich.

\subsection{Explizite Layout-Patterns}
\label{subsec:explicit-layout-patterns}

Die expliziten Layout-Patterns referenzieren Knoten im Diagramm und beschreiben deren Struktur anhand von geometrischen Eigenschaften. Während der Erstellung eines Diagramms werden ähnlich wie in \cite{Maier12A-Pattern-based} \textbf{Instanzen der Layout-Patterns} verwaltet. Im Gegensatz zu \cite{Maier12A-Pattern-based} erfolgt die Verwaltung automatisch und basiert auf dem Inhalt des Diagramms. Der Nutzer hat daher keine Möglichkeit die Layout-Patterns selbst zu erstellen\footnote{Eine eventuelle Möglichkeit der Erstellung von Layout-Patterns durch den Nutzer wird im Abschnitt \ref{subsec:algorithm-generalization} diskutiert.}.

Um eine Art der Manipulation der Knoten zu ermöglichen, wird das Konzept der \textbf{Variierung der expliziten Layout-Patterns} eingeführt. Je nach der Art des expliziten Layout-Patterns kann der Nutzer zwischen mehreren Variationen der Anordnung der Knoten (z.B. Reihenfolge) wählen. Das endgültige Layout wird jedoch durch die Geometrie bestimmt. Diese Art der Manipulation fördert die Konzentration auf den Inhalt und ergänzt die Einschränkung der freien Positionierung (Kriterium \ref{req:focus-on-the-content}).

Im Folgenden werden zwei konkreten expliziten Layout-Patterns vorgestellt, nämlich das Ausrichtungspattern (siehe Abschnitt \ref{subsubsec:alignment-pattern}) und das T-Shape-Pattern (siehe Abschnitt \ref{subsubsec:t-shape-pattern}). Mit der Implementierung der expliziten Layout-Patterns im Prototyp beschäftigt sich der Abschnitt \ref{subsubsec:patterns}.

\subsubsection{Ausrichtungspattern}
\label{subsubsec:alignment-pattern}

Das Ausrichtungspattern beschreibt eine Reihe an Knoten und kombiniert das Ausrichten und Verteilen der Knoten aus dem manuellen Layout (siehe Abschnitt \ref{subsubsec:alignment-and-distribution}) bzw. die Layout-Patterns zum Ausrichten und Verteilen aus \cite[S.143ff und S.136ff]{Maier12A-Pattern-based}. Die Knoten werden in eine horizontale oder vertikale Reihe gleichmäßig verteilt und an die Kanten bzw. Mittelpunkte ausgerichtet. In den Abbildungen \ref{fig:layout-pattern-alignment-center} und \ref{fig:layout-pattern-alignment-top} werden zwei Beispiele für das horizontale Verteilen mit der Ausrichtung an die oberen Kanten bzw. Mittelpunkte. Die gleichen Abstände sind mit roten Pfeilen und die Anordnung durch eine graue Linie gekennzeichnet.

\begin{figure}[hbt]
    \centering
    \includegraphics{resources/layout-pattern-alignment-center}
    \caption{Horizontales Ausrichtungspattern mit den Ausrichtung an die Mittelpunkte}
    \label{fig:layout-pattern-alignment-center}
\end{figure}

\begin{figure}[hbt]
    \centering
    \includegraphics{resources/layout-pattern-alignment-top}
    \caption{Horizontales Ausrichtungspattern mit den Ausrichtung an obere Kanten}
    \label{fig:layout-pattern-alignment-top}
\end{figure}

Die Variierung des Ausrichtungspatterns besteht in der Veränderung der Reihenfolge der ausgerichteten Knoten. Somit hat ein Ausrichtungspattern mit drei Knoten sechs möglichen Variationen. Dies ist in Abbildung \ref{fig:layout-pattern-alignment-variations} veranschaulicht.

\begin{figure}[hbt]
    \centering
    \includegraphics[scale=1.3]{resources/layout-pattern-alignment-variations}
    \caption{Mögliche Variationen des Ausrichtungspatterns mit drei Knoten}
    \label{fig:layout-pattern-alignment-variations}
\end{figure}

\subsubsection{T-Shape-Pattern}
\label{subsubsec:t-shape-pattern}

Das T-Shape-Pattern beschreibt die Struktur von Knoten, die in die Form des Buchstabes \enquote{T} angeordnet sind. Ein Knoten hat eine spezielle Rolle und ist den anderen Knoten übergeordnet. Die untergeordneten Knoten sind ähnlich wie in dem Ausrichtungspattern gleichmäßig in einer Reihe angeordnet und an die Kanten ausgerichtet, die sich am nächsten zu dem übergeordneten Knoten befinden. Der übergeordnete Knoten befindet sich in einem definierten Abstand zu den untergeordneten Knoten und ist mittig ausgerichtet. In Abbildung \ref{fig:layout-pattern-t-shape} ist ein Beispiel des T-Shape-Patterns dargestellt, in dem der übergeordnete Knoten oben positioniert ist. Die Abstände sind mit farbigen Pfeilen und die Ausrichtung mit grauen Linien gekennzeichnet. Natürlich gibt es weitere Formen des T-Shape-Patterns, in den sich der übergeordnete Knoten links, unten oder rechts befindet.

\begin{figure}[hbt]
    \centering
    \includegraphics{resources/layout-pattern-t-shape}
    \caption{Das T-Shape-Pattern mit dem oben positionierten übergeordneten Knoten}
    \label{fig:layout-pattern-t-shape}
\end{figure}

Das T-Shape-Pattern erweitert das Ausrichtungspattern, indem die Reihe der untergeordneten Knoten um einen übergeordneten Knoten ergänzt wird. Identisch wie bei dem Ausrichtungspattern lässt sich bei dem T-Shape-Pattern die Reihenfolge der untergeordneten Knoten verändern.

%%%%%%%%%%%%%%%%%%%%%%
% Layout Calculation %
%%%%%%%%%%%%%%%%%%%%%%

\section{Berechnung des Layouts}
\label{sec:layout-calculation}

Wie bereits im Abschnitt \ref{subsec:edit-actions} erläutert wurde, werden während der Bearbeitung eines Diagramms Aktionen durch den Nutzer ausgeführt. Für die ausgeführten Bearbeitungsaktionen werden \textbf{Layout-Ereignisse} generiert, die eine Beschreibung der manipulierten bzw. geänderten Knoten und Kanten sowie die Parameter der Interaktion wie z.B. die Position des Mauszeigers beinhalten. Die \textbf{Layout-Engine}, die für die Berechnung des Layouts zuständig ist, nimmt die erzeugten Layout-Ereignisse entgegen, verarbeitet sie und passt das Layout des Diagramms an. Mit der Layout-Engine beschäftigt sich näher der Abschnitt \ref{subsec:layout-engine}. Der Prozess der Verarbeitung der Layout-Ereignisse wird im Abschnitt \ref{subsec:processing-of-layout-events} beschrieben. Schließlich werden die konkreten Layout-Algorithmen im Abschnitt \ref{subsec:concrete-layout-algorithms} vorgestellt.

\subsection{Layout-Engine}
\label{subsec:layout-engine}

Die Layout-Engine ist ein zentraler Bestandteil des präsentierten Ansatzes. Sie ist mit dem bearbeiteten Diagramm verknüpft, dessen Layout sie berechnet. Des Weiteren verwaltet sie Instanzen von expliziten Layout-Patterns (siehe Abschnitt \ref{subsec:explicit-layout-patterns}), wodurch die Struktur des Diagramms beschrieben wird.

Um mit dem Prozess der Verarbeitung der Layout-Ereignisse beginnen zu können, muss sich die Layout-Engine in einem \textbf{validen Zustand} befinden. Dies wird entweder durch das Speichern des Zustandes der Layout-Engine oder durch die Berechnung eines initialen Layouts gewährleistet. Die Aufgabe der zuletzt genannten Option besteht darin, die expliziten Layout-Patterns ähnlich wie in \cite{MaierMinas13A-Pattern-based} anhand des Inhalts des Diagramms automatisiert zu instanziieren.

\subsection{Verarbeitung der Layout-Ereignisse}
\label{subsec:processing-of-layout-events}

Der Lebenszyklus der Layout-Engine besteht aus der sequenziellen Verarbeitung der Layout-Ereignisse, die nach bzw. während der Ausführung von Bearbeitungsaktionen erzeugt werden. Sobald die Layout-Engine ein Layout-Ereignis empfängt, verarbeitet sie dieses sofort. Der Prozess der Verarbeitung der Layout-Ereignisse besteht aus zwei Phasen und ist in Abbildung \ref{fig:processing-of-layout-events} schematisiert.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=\textwidth]{resources/processing-of-layout-events}
    \caption{Schema der Verarbeitung der Layout-Ereignisse}
    \label{fig:processing-of-layout-events}
\end{figure}

Je nach der Art des Layout-Ereignisses werden in der \textbf{ersten Phase} die Instanzen der expliziten Layout-Patterns angepasst, indem:

\begin{itemize}
    \item neue Layout-Patterns erstellt bzw. bestehende  Layout-Patterns gelöscht,
    \item die Referenzen auf Knoten der bestehenden Layout-Patterns modifiziert
    \item oder die bestehenden Layout-Patterns variiert werden.
\end{itemize}

Insbesondere wird dabei von dem aktuellen Zustand des Diagramms, den bereits instanziierten Layout-Patterns und der Information über die Interaktion Gebrauch gemacht. Das genaue Verhalten der Anpassung der Layout-Patterns ist jedoch von einer konkreten Layout-Engine abhängig, die für den gewählten Diagrammtyp ausgelegt ist. Dieser Sachverhalt wird im Abschnitt \ref{subsec:concrete-layout-algorithms} diskutiert und an konkreten Beispielen illustriert.

In der \textbf{zweiten Phase} wird das \textbf{Layout} berechnet, das durch die impliziten und instanziierten expliziten Layout-Patterns eindeutig bestimmt ist und die Positionen für alle Knoten im Diagramm enthält\footnote{Es wäre möglich, auch weitere Layout-Eigenschaften wie Routen für die Kanten oder Parameter der Layout-Übergänge zu berechnen. Dies wurde in dieser Arbeit aus zeitlichen Gründen jedoch außer Acht gelassen.}. Sobald sich das neu berechnete Layout von dem aktuellen unterscheidet, wird das neue Layout auf das Diagramm angewendet und dadurch ein Layout-Übergang erzeugt (siehe Abschnitt \ref{subsec:layout-transition}). Damit wird die Verarbeitung des Layout-Ereignisses abgeschlossen und der gesamte Vorgang fängt für das nächste Layout-Ereignis von vorne an.

In Rahmen der Konzeption und Entwicklung wurde zunächst ein Algorithmus entworfen, der für die Verschiebung eines Knotens alle erreichbaren Layouts berechnet hat. Weiterhin wurde der Canvas in Bereiche aufgeteilt, wobei jeder Bereich auf ein berechnetes Layout abgebildet wurde. Durch die Bewegung der Mauszeigers in einen bestimmten Bereich wurde das abgebildete Layout auf das Diagramm angewendet und dadurch ein Layout-Übergang ausgelöst. Da die Aufteilung nach jedem Layout-Übergang nicht aktualisiert wurde, war sie oft nach dem ersten Layout-Übergang ungültig. Später wurde festgelegt, dass dieser Algorithmus nicht hinreichend ist.

In dem präsentierten Ansatz wird während der Ausführung einer Verschiebungsaktion ein Layout-Ereignis für jede Bewegung des Mauszeigers generiert und verarbeitet. Dabei sollen bei dem Entwurf eines konkreten Algorithmus folgende Eigenschaften beachtet werden:

\begin{itemize}
    \item \textbf{Stabilität} Während der Ausführung einer Verschiebungsaktion soll ein Layout-Übergang erst nach einer deutlichen Bewegung des Mauszeigers durch den Nutzer ausgelöst werden.
    \item \textbf{Erreichbarkeit des Ausgangslayouts} Das Layout, das ein Diagramm annimmt, wenn die Verschiebungsaktion beginnt, soll im Verlauf der Ausführung der Verschiebungsaktion stets erreichbar sein.
\end{itemize}

\subsection{Konkrete Layout-Algorithmen}
\label{subsec:concrete-layout-algorithms}

Im Abschnitt \ref{subsec:processing-of-layout-events} wurde der Rumpf des Algorithmus für die Berechnung des Layouts vorgestellt. Dabei wurde nicht auf die interne Funktionsweise der Layout-Engine eingegangen. Das liegt daran, dass die Layout-Engine ein unterschiedliches Verhalten für verschiedene \textbf{Diagrammtypen} aufweisen soll, denn jeder Diagrammtyp (z.B. Klassendiagramm, Zustandsdiagramm, Flowchart usw.) hat aufgrund der Syntax- und Semantikregeln spezielle Anforderungen an des ästhetische Layout. Nur dadurch kann das Kriterium \ref{req:syntax-and-semantics} erfüllt werden.

Die in dieser Arbeit präsentierten Algorithmen basieren auf der visuellen Sprache der Klassendiagramme der Notationssprache UML. Allerdings handelt es sich um keine allgemeine Algorithmen für das Layout von Klassendiagrammen, sondern um zwei relativ einfache Algorithmen, deren Aufgabe es ist, die eingeführten Mechanismen der Interaktion zu validieren und damit das gesamte Konzept zu prüfen. Daher wird der Einfachheit halber kein UML-Metamodell eingesetzt und die Syntax wird stark eingeschränkt. Es werden nur vereinfachte Klassen (Knoten) und Vererbungsrelation (Kanten) unterstützt.

\subsubsection{Algorithmus für das horizontale Layout}
\label{subsubsec:horizontal-layout-algorithm}

Der Algorithmus für das horizontale Layout ordnet alle Klassen eines Klassendiagramms in eine horizontale Reihe an und lässt dabei die Vererbungsrelationen außer Acht.

Die Layout-Engine, die diesen Algorithmus umsetzt, enthält intern eine Instanz des Ausrichtungspatterns (siehe Abschnitt \ref{subsubsec:alignment-pattern}), das alle Klassen des Diagramms referenziert. Dieser Algorithmus hat aus der Sicht des Nutzers keine große Bedeutung und dient ausschließlich als Grundlage für den Algorithmus für das baumbasierte Layout, mit dem sich der Abschnitt \ref{subsubsec:tree-layout-algorithm} beschäftigt.

Nichtsdestotrotz macht der Algorithmus die Mechanismen der Interaktion aus dem Abschnitt \ref{sec:interaction-mechanisms} verständlich. Insbesondere zeigt die Verschiebungsaktion die Möglichkeit der Änderung der Reihenfolge der Klassen im Diagramm. Dies wird durch die Layout-Engine in eine direkte Variierung des Ausrichtungspatterns übersetzt. Eine Veranschaulichung der prototypischen Implementierung des Algorithmus für das horizontale Layout ist dem Video unter dem Pfad \texttt{Prototype/Videos/Hori\-zon\-tal-\-Lay\-out-\-De\-mo.mov} auf der unter Anhang \ref{chapter:dvd} eingereichten DVD zu entnehmen.

\subsubsection{Algorithmus für das baumbasierte Layout}
\label{subsubsec:tree-layout-algorithm}

Der Algorithmus für das baumbasierte Layout ermöglicht die Modellierung von Vererbungshierarchien in einem Klassendiagramm und hält sich dabei an die im Abschnitt \ref{sec:aesthetics-criteria} beschriebene ästhetischen Kriterien.
% TODO: Verweis auf ästhetische Kriterien aus dem Kapitel 2 überprüfen

Ähnlich wie bei der Umsetzung des Algorithmus für das horizontale Layout (siehe Abschnitt \ref{subsubsec:horizontal-layout-algorithm}) enthält die Layout-Engine, die den Algorithmus für das baumbasierte Layout umsetzt, eine Instanz des horizontalen Ausrichtungspatterns, das jedoch nicht alle Klassen im Diagramm sondern nur die Wurzelklassen der Vererbungshierarchien referenziert. Durch dieses globale Ausrichtungspattern wird die Reihenfolge der Vererbungshierarchien bestimmt. Während der Erstellung von Vererbungsrelationen zwischen Klassen werden T-Shape-Patterns (siehe Abschnitt \ref{subsubsec:t-shape-pattern}) instanziiert, die die Struktur der Vererbungshierarchien beschreiben und durch die Layout-Engine verwaltet werden. In Abbildung \ref{fig:tree-based-layout} wird ein Beispiel eines Diagramms mit gekennzeichneten Layout-Patterns gezeigt. Die blaue Linie stellt das globale Ausrichtungspattern dar und mit den grünen Linien sind die instanziierten T-Shape-Patterns markiert. Die Vererbungshierarchien sind mit grauen gestrichelten Linien umrandet.

\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.7\textwidth]{resources/tree-based-layout}
    \caption{Visualisierung von Instanzen der expliziten Layout-Patterns im baumbasierten Layout}
    \label{fig:tree-based-layout}
\end{figure}

Die Berechnung des endgültigen Layouts erfolgt durch die Zusammensetzung der instanziierten expliziten Layout-Patterns. Dabei wird die oben beschriebene Vereinfachung der Klassendiagramme ausgenutzt und der Algorithmus ist somit ausschließlich für diesen konkreten Fall geeignet. Die Möglichkeit der Entwicklung eines allgemeinen Algorithmus für Klassendiagramme wird im Abschnitt \ref{subsec:algorithm-generalization} diskutiert.

Je nachdem welche Klasse verschoben wird, verhält sich die Verschiebungsaktion unterschiedlich. Das Verschieben der Wurzelklassen bewirkt die Änderung der Reihenfolge der Vererbungshierarchien. Wenn aber eine Klasse, die sich in einer Vererbungshierarchie unter der Wurzelklasse befindet, verschoben wird, wird die Reihenfolge der Geschwisterklassen angepasst, indem das zugehörige T-Shape-Pattern variiert wird (siehe Abschnitt \ref{subsubsec:t-shape-pattern}). Zum besseren Verständnis der Funktionsweise wird auf ein Video mit der Vorführung der prototypischen Implementierung verwiesen. Das Video ist unter dem Pfad \texttt{Prototype/Videos/Tree-based-Layout-\-De\-mo.mov} auf der unter Anhang \ref{chapter:dvd} eingereichten DVD zu finden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Current Approaches Comparison %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Abgrenzung zu bestehenden Ansätzen}
\label{sec:current-approaches-comparison}

% Was ist neu an dem Ansatz?
% Vergleich zu bestehenden Ansätzen im Kapitel 3
% Worin unterscheidet sich mein Ansatz zu dem von Sonja Maier?
% - \enquote{Drag and Drop} mit Visualisierung der Aktion
% - Kein Freihand-Editieren, sondern implizite Bereiche und Layout-Übergänge
% - Patterns unterstützen Variierung
% - Starke Vereinfachung der Möglichkeiten (Anpassung der Patterns aus [Maier])

% Unterschied zu visuellen automatischen Ansätzen:
% - Interaktion und Zustand wird berücksichtigt

%%%%%%%%%%%
% Summary %
%%%%%%%%%%%

\section{Zusammenfassung}
\label{sec:approach-summary}

% Herausforderung bei der Kombination von mehreren Kriterien (z.B. interaktive Bedienung aber gleichzeitig eine Einschränkung der Möglichkeiten)
% Der Mechanismus ist für klassische grafische Benutzeroberflächen ausgelegt und erfüllt damit das Kriterium \ref{req:gui}.

% Neu-Berechnung nach jedem Layout-Übergang -> Performance?

% Klassendiagramme meistens weniger als 10 Klassen (Rat von Scott Ambler?)
% Durch die Spezialisierung auf konkrete Diagramm-Typen und den Einsatz von verschiedenen Vereinfachungsmaßnahmen wie etwa Einschränkung der unterstützten Notation \cite[S.56ff]{Ambler02Agile} lassen sich Algorithmen für das Layout von Softwarediagrammen entwerfen, die zwar nicht so flexibel wie z.B. \cite{Maier12A-Pattern-based} oder \cite{Eichelberger05Aesthetics} sind, aber dafür...
