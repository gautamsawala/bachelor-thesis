%%%%%%%%%%%%%%%%
% Introduction %
%%%%%%%%%%%%%%%%

\chapter{Einleitung}

\section{Motivation}

Der Einsatz von Agilität in der Softwareentwicklung, bekannt unter dem Begriff \textbf{agile Softwareentwicklung}, erfreut sich heutzutage einer großen Beliebtheit. In der Umfrage \enquote{State of Agile} der Firma VersionOne aus dem Jahr 2013 haben 88\% der befragten Personen aus nordamerikanischen und europäischen Softwareentwicklungsunternehmen bestätigt, dass in ihren Organisationen agile Softwareentwicklung eingesetzt wird. Die Umfrage zeigt weiterhin, dass dieser Anteil in den letzten 3 Jahren eine steigende Tendenz hat \cite{VersionOne148th-Annual}.

Agile Softwareentwicklung basiert auf den Grundsätzen aus \cite{BeckBeedle01Manifest} und die agilen Softwareentwicklungsprozesse sind im Vergleich zu den traditionellen und schwergewichtigen (wie z.B. Unified Process oder Wasserfallmodell) schlanker, flexibler und für die Bedürfnisse der heutigen Zeit angepasst. Des Weiteren stellt die agile Softwareentwicklung den Code in Fokus und unterstützt dies durch zahlreiche Praktiken wie z.B. testgetriebene Entwicklung, Code-Refactoring oder Code-Reviews. Insbesondere bei kleinen Entwickler-Teams und Einzelentwicklern, die Anwendungen für moderne Plattformen entwickeln\footnote{mobile Apps, Webanwendungen, Endbenutzer-Desktop-Anwendungen}, wird während der Entwicklung in der Regel auf Modellierung und umfassende Dokumentation mit Hilfe von UML-Diagrammen verzichtet.

Der agile Ansatz lässt sich jedoch auch in die Softwaremodellierung übertragen. Die Grundlage dafür bildet die in \cite{Ambler02Agile} von Scott W. Ambler präsentierte Methodik \textbf{Agile Modeling}. Diese auf Praktiken basierte Methodik zeigt, dass effektive Softwaremodellierung auch im agilen Umfeld Vorteile bringt. Die Methodik empfiehlt, mit den einfachsten Tools leichtgewichtige Modelle zu erstellen, die einen bestimmten Zweck erfüllen, z.B. einen Sachverhalt  veranschaulichen oder die Kommunikation zwischen mehreren Team-Mitgliedern verbessern. Weiterhin soll keine zu komplizierte Notation\footnote{Der Autor rät dazu, eine hilfreiche Teilmenge der UML-Notation aber auch weitere Diagrammtypen und deren Notationen wie z.B. Flowcharts zu verwenden.} verwendet werden. Wenn der Inhalt der Modelle bereits im Code umgesetzt ist und die Modelle dem Projekt keinen Mehrwert mehr geben, sollen sie verworfen werden \cite{Ambler02Agile}.

Zum einen können die Modelle in Form von Skizzen auf \textbf{Papier oder Whiteboards} gezeichnet werden. Dies ist eine schnelle, praktische und unmittelbare Lösung. Leider ist sie für nachträgliche Änderungen und Korrekturen nicht geeignet, erschwert die Lesbarkeit und verfügt über keine syntaktische und semantische Unterstützung.

Zum anderen bietet sich für die Erstellung der Modelle der Einsatz eines \textbf{Zeichentools}\footnote{Beispiel eines Zeichentools ist OmniGraffle, das näher im Abschnitt \ref{subsubsec:omnigraffle} behandelt wird.} an. Die Zeichentools beheben die Probleme mit dem statischen Charakter von Papier und bieten zusätzlich einen Vorteil durch die digitale Version. Jedoch unterstützen sie in der Regel keine Semantik und oft ist auch die Unterstützung der Syntax mangelhaft. So muss z.B. in einigen Zeichentools das Klassenelement für Klassendiagramme mit einem Rechteck und mehreren Textfeldern zusammengebaut werden.

Die \textbf{CASE-Tools}, die für Softwaremodellierung konzipiert sind und sowohl die Syntax als auch die Semantik der Modellierungssprache unterstützen, können ebenfalls für die Erstellung der Modelle verwendet werden. Obwohl die Nutzung von CASE-Tools in der Methodik Agile Modeling nicht untersagt ist, sind diese Werkzeuge für Erzeugung von eifachen Modellen in der Regel sehr komplex und schwergewichtig.

Es stellt sich heraus, dass verfügbare Software-Tools nur eine unbefriedigende Unterstützung für die agile Modellierung bieten. Ein für die agile Modellierung geeignetes Tools soll neben einer einfachen Modellerstellung und den Prinzipien aus \cite{Ambler02Agile} auch die syntaktischen und semantischen Aspekte der Modellierungssprache unterstützen. Weiterhin soll der Inhalt des Diagramms im Fokus stehen. Schließlich soll die Interaktion mit dem Diagramm gefördert werden, unter anderem durch eine intelligente Layout-Unterstützung, die den Gegenstand dieser Arbeit bildet.

\section{Zielstellung}

In dieser Arbeit soll ein Konzept für eine interaktive und diagrammspezifische Layout-Un\-ter\-stüt\-zung in visuellen Editoren im Desktop-Bereich\footnote{Die Desktop-Editoren zeichnen sich dadurch aus, dass sie auf Fenstern basieren und die Bedienung mit der Maus und Tastatur erfolgt. Andere Eingabemöglichkeiten wie z.B. Multi-Touch werden in dieser Arbeit nicht behandelt.} erarbeitet werden. Der Schwerpunkt wird dabei auf graphbasierte Softwarediagramme gelegt, insbesondere wird auf Klassendiagramme eingegangen. Das Ziel ist es, eine mögliche Richtung der interaktiven Layout-Unterstützung in leichtgewichtigen Softwaremodellierungswerkzeugen vorzustellen.

% TODO: Kategorisierung näher beschreiben (wonach...)

Im Rahmen der Arbeit sollen bestehende Ansätze für das Layout von Diagrammen untersucht und kategorisiert werden. Die durchgeführte Analyse soll bei dem Erarbeiten des Konzepts berücksichtigt werden. Weiterhin sollen die Layoutmechanismen in einem Prototyp implementiert werden und in Form einer Nutzerstudie evaluiert werden.

% TODO: Erweitern, wenn die restlichen Teile der Arbeit fertig werden

\section{Rahmenbedingungen}
\label{sec:thesis-conditions}

Obwohl es bereits Ansätze für die Bearbeitung von Diagrammen mit fortgeschrittenen Bedienungsparadigmen wie Multi-Touch gibt (z.B. in \cite{FrischHeydekorn10Diagram}), beschäftigt sich diese Arbeit ausschließlich mit Ansätzen für das Layout von Diagrammen im Bereich der Desktop-Anwendun\-gen.

% TODO: Rahmenbedingungen ergänzen!
% - Beispiele und Apps: Mac OS X
% - da deren Einsatz der Desktop-Systemen für Diagramm-Bearbeitung überwiegt

\section{Aufbau der Arbeit}

% Im Kapitel 3 werden bestehende Ansätze kategorisiert und im Detail vorgestellt, u.a. handelt es sich um kommerzielle Anwendungen, Code-Bibliotheken und Forschungsprojekte.
