%%%
% Concept for an Interactive Approach
%%%

\chapter{Konzept für das interaktive Layout von graph-basierten Softwarediagrammen}

% Was kann der Nutzer verändern?
% Was kann er tun?
% Arten der Manipulation auflisten
% Was ist neu an dem Ansatz?

% Drag&Drop-Technik (neue Elemente aus einer Palette bzw. Änderung des Layout im Diagramm)

% absolutes Layout:
% - alle mögliche Layout berechnen
% - Bereiche für alle Layouts berechnen
% - Layout des Diagramms ändern, wenn der Mauszeiger in einen der Bereiche übergeht
% > Berechnung der Bereiche einmal am Anfang einer Verschiebungsoperation für das gesamte Diagramm
% > keine Änderung der Bereiche nach einem Layout-Übergang
% > Möglichkeit von Cache des Layout-Mappings für den zuletzt manipulierten Knoten
% > Probleme mit der Ungültigkeit nach dem ersten Layout-Übergang

% relative Layout-Berechnung
% > Berechnung des Layout-Mappings nach jedem Layout-Übergang und zwar nut relativ für den manipulierten Knoten (z.B. nur die benachbarten Bereiche im horizontalen Layout-Algorithmus)
% > kein Caching
% > nach einem Layout-Übergang muss sich das Layout-Mapping in einem stabilen Zustand befinden

% Layout-Engine speziell für Diagrammtypen
% IDLLayoutEngine & Subclasses (bzw. unterstützte Engines)
% berechnet Layouts = Positionen für Knoten, Routen für Kanten (nicht implementiert), Animationen/Übergangsparameter für die Transitionen (nicht implementiert)
% Eingabe für den Algorithmus: Layout-Event, Inhalt des Diagramms, instanziierte Patterns

% Möglichkeit in den initialen Zustand zu übergehen
% bei Knotenverschiebung nicht nach dem Drag sofort einen Layout-Übergang ausführen

%Algorithmus-Beschreibung
%Layout-Patterns
%	implizite und explizite
%	detaillierte Beschreibung der expliziten Layout-Patterns mit Bezug auf Arbeiten
%Worin unterscheidet sich mein Ansatz zu dem von Sonja Maier?
%Für welche Diagramme geeignet? (Klassendiagramme, Objektdiagramme, Komponentendiagramme, Graphen, Bäume)
%Vergleich zu bestehenden Ansätzen im Kapitel 3

% kombiniert Vorteile der freien Positionierung der Elemente im Diagramm und der automatischen Layout-Algorithmen miteinander

% immediate feedback vs. delayed feedback [Wybrow S.69]

% Unterschied Top vs. Center Horizontal Alignment Pattern (mit einem Bild erklärt)

% IDLPattern, IDLAlignmentPattern, IDLTShapePattern -> Klassendiagramm
% Beschreibung der Patterns mit Bildern (geometrische Parameter erläutern)
% Bild mit Instanzen von Patterns in einem Beispiel-Diagramm (kann ein Screenshot sein)

% Layout-Komposition mit Hilfe von Sublayouts

% die Eingabe ist mit der Angabe gekoppelt (footnote: Aus der Sicht der HCI ist die Nutzung der Maus als Eingabegerät von der Ausgabe am Monitor entkoppelt.)

% Explizite absolute vs. implizite relative Berechnung der Layout-Bereiche
% In Rahmen der Entwicklung wurde mit expliziten absoluten Bereichen experimentiert (absolut für das gesamte Diagramm)

% Vereinfachung der Diagramme (Agile Modeling) -> Möglichkeiten der Umsetzung von Algorithmen, die nicht so flexible sein müssen (REQ_COMPL_UML)

% Patterns
% ========
% Patterns-Variierung
% z.B. Reihenfolge der Knoten kann von Nutzer festgelegt werden, das endgültige Layout wird durch die Geometrie bestimmt
% instanziiert in der Layout-Engine, referenzieren den Diagramm-Inhalt
% Wiederverwendung möglich (mehrere Instanzen in der Layout-Engine bzw. Komposition von Patterns wie T-Shape-Pattern)
% Nur während Drag&Drop sichtbar -> Möglichkeit der Interaktivität der Patterns

% Mentales Modell -> Animation, Platzhalter

% Insbesondere haben die Syntax und Semantik der Diagramme keinen Einfluss auf das Layout
